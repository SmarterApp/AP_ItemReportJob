package org.opentestsystem.ap.irj.service;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.apache.commons.lang3.math.NumberUtils;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.api.errors.RefNotFoundException;
import org.opentestsystem.ap.common.client.GitClient;
import org.opentestsystem.ap.common.config.ItemBankProperties;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemBankSystemUser;
import org.opentestsystem.ap.common.model.ValidationResult;
import org.opentestsystem.ap.common.repository.ItemRepository;
import org.opentestsystem.ap.irj.config.ApplicationProperties;
import org.opentestsystem.ap.irj.model.BaseItem;
import org.opentestsystem.ap.irj.model.LoadResult;
import org.opentestsystem.ap.irj.model.ReportError;
import org.opentestsystem.ap.irj.repository.ReportRepository;
import org.opentestsystem.ap.irj.util.ReportUtil;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.function.Predicate;

import static java.util.Comparator.comparing;
import static java.util.stream.Collectors.toList;
import static org.opentestsystem.ap.common.model.ItemConstants.Section.SECTION_CREATE;
import static org.opentestsystem.ap.irj.model.ReportConstants.Status.STATUS_CREATING;
import static org.opentestsystem.ap.irj.model.ReportConstants.Status.STATUS_FAILED;
import static org.opentestsystem.ap.irj.model.ReportConstants.Status.STATUS_SUCCESS;

@Slf4j
@Component
public class ItemReportService {

    private static final List<ValidationResult> EMPTY_VALIDATION_RESULTS = Collections.emptyList();

    private final ItemBankSystemUser systemUser;

    private final ApplicationProperties applicationProperties;

    private final ItemBankProperties itemBankProperties;

    private final ItemRepository itemRepository;

    private final ReportRepository reportRepository;

    public ItemReportService(final ApplicationProperties applicationProperties,
                             final ItemBankProperties itemBankProperties,
                             final ItemRepository itemRepository,
                             final ReportRepository reportRepository) {
        this.applicationProperties = applicationProperties;
        this.itemBankProperties = itemBankProperties;
        this.itemRepository = itemRepository;
        this.reportRepository = reportRepository;

        this.systemUser = new ItemBankSystemUser(
            applicationProperties.getSystemUserName(), applicationProperties.getSystemFullName());
    }

    // ------------------------------------------------------------------------

    /**
     * Returns the folders in the local base directory.  Only the first level of folders are returned, so only the
     * children of the local base dir.
     *
     * @return A list of folders in the local base directory.
     */
    public List<Path> findFoldersInLocalItemBank() {
        final Path rootPath = Paths.get(itemBankProperties.getLocalBaseDir());
        try {
            log.debug("findFoldersInLocalItemBank: base folder {}", itemBankProperties.getLocalBaseDir());
            return Files.walk(rootPath, 1).filter(Files::isDirectory).collect(toList());
        } catch (IOException e) {
            throw new SystemException("Error getting folders in local item bank", e);
        }
    }

    // -------------------------------------------------------------------------

    public void createLocalItemBankFolder() {
        final Path rootPath = Paths.get(itemBankProperties.getLocalBaseDir());

        try {
            final boolean successful = rootPath.toFile().createNewFile();
            log.info("Successfully created {}", rootPath);
        } catch (IOException e) {
            log.error("Error creating item bank folder " + rootPath, e);
        }
    }

    public void deleteLocalItemBank() {
        final Path rootPath = Paths.get(itemBankProperties.getLocalBaseDir());
        ReportUtil.deleteFolder(rootPath);
    }

    /**
     * If the path last modified date is before the given date true is returned.  False otherwise.
     *
     * @param date The date to compare the path last modified data against.
     * @return If the path last modified date is before the given date true is returned.  False otherwise.
     */
    private Predicate<Path> isFolderOlderThan(final Date date) {
        return path -> path.toFile().lastModified() < date.getTime();
    }

    /**
     * If the paths are not equal then true is returned.
     *
     * @param pathToCompare The path to compare.
     * @return True if the two paths are not equal.
     */
    private Predicate<Path> isPathNotEqual(final Path pathToCompare) {
        return path -> !StringUtils.equals(pathToCompare.toString(), path.toString());
    }

    // -------------------------------------------------------------------------

    /**
     * Returns the item ids of all the items in the item bank.
     *
     * @return A list of item ids.
     */
    public List<String> findAllItemNames() {
        final List<String> ids = itemRepository.findAllItemNames();

        final List<String> filteredIds = ids.stream()
            .filter(NumberUtils::isDigits)
            .filter(id -> {
                try {
                    return Integer.parseInt(id) < 600000000;
                } catch (Exception e) {
                    return false;
                }
            })
            .collect(toList());
        filteredIds.sort(comparing(Integer::valueOf));

        return filteredIds;
    }

    public LoadResult loadItem(final String itemId) {
        return loadItemWithRetry(itemId, true);
    }

    public LoadResult loadItemWithRetry(final String itemId, final boolean retryGitAPIException) {
        Item item;
        LoadResult result;
        ReportError error = null;
        GitClient client = null;
        try {
            client = itemRepository.openRepository(systemUser, itemId);
            item = client.readModelFile();
            result = new LoadResult(item, STATUS_SUCCESS, EMPTY_VALIDATION_RESULTS, error);
        } catch (Exception e) {
            if (e.getCause() instanceof FileNotFoundException) {
                result = handleFileNotFoundException(client, itemId);
            } else if (e.getCause() instanceof GitAPIException) {
                if (retryGitAPIException) {
                    result = handleGitAPIException(client, itemId);
                } else {
                    error = new ReportError(itemId, ExceptionUtils.getRootCauseMessage(e));
                    result = new LoadResult(new BaseItem(itemId), STATUS_FAILED, EMPTY_VALIDATION_RESULTS, error);
                }
            } else {
                error = new ReportError(itemId, ExceptionUtils.getRootCauseMessage(e));
                result = new LoadResult(new BaseItem(itemId), STATUS_FAILED, EMPTY_VALIDATION_RESULTS, error);
            }
        }

        return result;
    }

    /**
     * Assumes there is an issue with the local repository for the item, so it is deleted then cloned from the remote
     * origin.
     *
     * @param client The git client pointing to the item.
     * @param itemId The item.
     * @return The results of loading the item from the create branch.
     */
    private LoadResult handleGitAPIException(final GitClient client, final String itemId) {
        try {
            client.deleteLocalRepo();
            client.cloneRemoteRepository();
        } catch (Exception e) {
        }
        return loadItemWithRetry(itemId, false);
    }

    /**
     * Checks the create branch, if one exists, and loads the item data from there.
     *
     * @param client The git client pointing to the item.
     * @param itemId The item.
     * @return The results of loading the item from the create branch.
     */
    private LoadResult handleFileNotFoundException(final GitClient client, final String itemId) {
        LoadResult result;
        Item item = null;
        ReportError error = null;
        try {
            final String branch = itemRepository.findBranchBySection(itemId, SECTION_CREATE);
            client.checkoutBranch(branch);
            client.pullLatest();

            item = client.readModelFile();

            result = new LoadResult(item, STATUS_CREATING, EMPTY_VALIDATION_RESULTS, error);
        } catch (Exception e) {
            error = new ReportError(itemId, ExceptionUtils.getRootCauseMessage(e));
            result = new LoadResult(item, STATUS_FAILED, EMPTY_VALIDATION_RESULTS, error);
        }
        return result;
    }

    @Async
    public CompletableFuture<LoadResult> loadItemAsync(final String itemId) {
        log.info("Load item {}", itemId);
        final LoadResult loadResult = loadItem(itemId);
        return CompletableFuture.completedFuture(loadResult);
    }

    public List<Path> findReportRepositoryFiles() {
        return reportRepository.findReportRepositoryFiles(systemUser);
    }

    public void stageAndCommitAllFiles() {
        reportRepository.stageAndCommitAllFiles(systemUser);
    }

    public void deleteReportRepository() {
        reportRepository.deleteReportRepository(systemUser);
    }
}
